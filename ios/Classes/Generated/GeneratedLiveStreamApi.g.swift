// Autogenerated from Pigeon (v22.4.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
    import Flutter
#elseif os(macOS)
    import FlutterMacOS
#else
    #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class PigeonError: Error {
    let code: String
    let message: String?
    let details: Any?

    init(code: String, message: String?, details: Any?) {
        self.code = code
        self.message = message
        self.details = details
    }

    var localizedDescription: String {
        return
            "PigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
    }
}

private func wrapResult(_ result: Any?) -> [Any?] {
    return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
    if let pigeonError = error as? PigeonError {
        return [
            pigeonError.code,
            pigeonError.message,
            pigeonError.details,
        ]
    }
    if let flutterError = error as? FlutterError {
        return [
            flutterError.code,
            flutterError.message,
            flutterError.details,
        ]
    }
    return [
        "\(error)",
        "\(type(of: error))",
        "Stacktrace: \(Thread.callStackSymbols)",
    ]
}

private func createConnectionError(withChannelName channelName: String) -> PigeonError {
    return PigeonError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
}

private func isNullish(_ value: Any?) -> Bool {
    return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
    if value is NSNull { return nil }
    return value as! T?
}

/// Audio channel
enum NativeChannel: Int {
    /// Stereo (2 channels)
    case stereo = 0
    /// Mono (1 channel)
    case mono = 1
}

/// Camera facing direction
enum NativeCameraLensDirection: Int {
    /// Front camera
    case front = 0
    /// Back camera
    case back = 1
    /// Other camera (external for example)
    case other = 2
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeResolution {
    var width: Int64
    var height: Int64

    // swift-format-ignore: AlwaysUseLowerCamelCase
    static func fromList(_ pigeonVar_list: [Any?]) -> NativeResolution? {
        let width = pigeonVar_list[0] as! Int64
        let height = pigeonVar_list[1] as! Int64

        return NativeResolution(
            width: width,
            height: height
        )
    }

    func toList() -> [Any?] {
        return [
            width,
            height,
        ]
    }
}

/// Live streaming audio configuration.
///
/// Generated class from Pigeon that represents data sent in messages.
struct NativeAudioConfig {
    /// The video bitrate in bps
    var bitrate: Int64
    /// The number of audio channels
    /// Only available on Android
    var channel: NativeChannel
    /// The sample rate of the audio capture
    /// Only available on Android
    /// Example: 44100, 48000, 96000
    /// For RTMP sample rate, only 11025, 22050, 44100 are supported
    var sampleRate: Int64
    /// Enable the echo cancellation
    /// Only available on Android
    var enableEchoCanceler: Bool
    /// Enable the noise suppressor
    /// Only available on Android
    var enableNoiseSuppressor: Bool

    // swift-format-ignore: AlwaysUseLowerCamelCase
    static func fromList(_ pigeonVar_list: [Any?]) -> NativeAudioConfig? {
        let bitrate = pigeonVar_list[0] as! Int64
        let channel = pigeonVar_list[1] as! NativeChannel
        let sampleRate = pigeonVar_list[2] as! Int64
        let enableEchoCanceler = pigeonVar_list[3] as! Bool
        let enableNoiseSuppressor = pigeonVar_list[4] as! Bool

        return NativeAudioConfig(
            bitrate: bitrate,
            channel: channel,
            sampleRate: sampleRate,
            enableEchoCanceler: enableEchoCanceler,
            enableNoiseSuppressor: enableNoiseSuppressor
        )
    }

    func toList() -> [Any?] {
        return [
            bitrate,
            channel,
            sampleRate,
            enableEchoCanceler,
            enableNoiseSuppressor,
        ]
    }
}

/// Live streaming video configuration.
///
/// Generated class from Pigeon that represents data sent in messages.
struct NativeVideoConfig {
    /// The video bitrate in bps
    var bitrate: Int64
    /// The live streaming video resolution
    var resolution: NativeResolution
    /// The video frame rate in fps
    var fps: Int64
    /// GOP (Group of Pictures) duration in seconds
    var gopDurationInS: Double

    // swift-format-ignore: AlwaysUseLowerCamelCase
    static func fromList(_ pigeonVar_list: [Any?]) -> NativeVideoConfig? {
        let bitrate = pigeonVar_list[0] as! Int64
        let resolution = pigeonVar_list[1] as! NativeResolution
        let fps = pigeonVar_list[2] as! Int64
        let gopDurationInS = pigeonVar_list[3] as! Double

        return NativeVideoConfig(
            bitrate: bitrate,
            resolution: resolution,
            fps: fps,
            gopDurationInS: gopDurationInS
        )
    }

    func toList() -> [Any?] {
        return [
            bitrate,
            resolution,
            fps,
            gopDurationInS,
        ]
    }
}

private class GeneratedLiveStreamApiPigeonCodecReader: FlutterStandardReader {
    override func readValue(ofType type: UInt8) -> Any? {
        switch type {
        case 129:
            let enumResultAsInt: Int? = nilOrValue(readValue() as! Int?)
            if let enumResultAsInt = enumResultAsInt {
                return NativeChannel(rawValue: enumResultAsInt)
            }
            return nil
        case 130:
            let enumResultAsInt: Int? = nilOrValue(readValue() as! Int?)
            if let enumResultAsInt = enumResultAsInt {
                return NativeCameraLensDirection(rawValue: enumResultAsInt)
            }
            return nil
        case 131:
            return NativeResolution.fromList(readValue() as! [Any?])
        case 132:
            return NativeAudioConfig.fromList(readValue() as! [Any?])
        case 133:
            return NativeVideoConfig.fromList(readValue() as! [Any?])
        default:
            return super.readValue(ofType: type)
        }
    }
}

private class GeneratedLiveStreamApiPigeonCodecWriter: FlutterStandardWriter {
    override func writeValue(_ value: Any) {
        if let value = value as? NativeChannel {
            super.writeByte(129)
            super.writeValue(value.rawValue)
        } else if let value = value as? NativeCameraLensDirection {
            super.writeByte(130)
            super.writeValue(value.rawValue)
        } else if let value = value as? NativeResolution {
            super.writeByte(131)
            super.writeValue(value.toList())
        } else if let value = value as? NativeAudioConfig {
            super.writeByte(132)
            super.writeValue(value.toList())
        } else if let value = value as? NativeVideoConfig {
            super.writeByte(133)
            super.writeValue(value.toList())
        } else {
            super.writeValue(value)
        }
    }
}

private class GeneratedLiveStreamApiPigeonCodecReaderWriter: FlutterStandardReaderWriter {
    override func reader(with data: Data) -> FlutterStandardReader {
        return GeneratedLiveStreamApiPigeonCodecReader(data: data)
    }

    override func writer(with data: NSMutableData) -> FlutterStandardWriter {
        return GeneratedLiveStreamApiPigeonCodecWriter(data: data)
    }
}

class GeneratedLiveStreamApiPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
    static let shared = GeneratedLiveStreamApiPigeonCodec(readerWriter: GeneratedLiveStreamApiPigeonCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol LiveStreamHostApi {
    func create() throws -> Int64
    func dispose() throws
    func setVideoConfig(videoConfig: NativeVideoConfig, completion: @escaping (Result<Void, Error>) -> Void)
    func setAudioConfig(audioConfig: NativeAudioConfig, completion: @escaping (Result<Void, Error>) -> Void)
    func startStreaming(streamKey: String, url: String) throws
    func stopStreaming() throws
    func startPreview(completion: @escaping (Result<Void, Error>) -> Void)
    func stopPreview() throws
    func getIsStreaming() throws -> Bool
    func getCameraId() throws -> String
    func setCameraId(cameraId: String, completion: @escaping (Result<Void, Error>) -> Void)
    func getIsMuted() throws -> Bool
    func setIsMuted(isMuted: Bool) throws
    func getVideoResolution() throws -> NativeResolution?
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
enum LiveStreamHostApiSetup {
    static var codec: FlutterStandardMessageCodec { GeneratedLiveStreamApiPigeonCodec.shared }
    /// Sets up an instance of `LiveStreamHostApi` to handle messages through the `binaryMessenger`.
    static func setUp(binaryMessenger: FlutterBinaryMessenger, api: LiveStreamHostApi?, messageChannelSuffix: String = "") {
        let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
        let createChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.apivideo_live_stream.LiveStreamHostApi.create\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            createChannel.setMessageHandler { _, reply in
                do {
                    let result = try api.create()
                    reply(wrapResult(result))
                } catch {
                    reply(wrapError(error))
                }
            }
        } else {
            createChannel.setMessageHandler(nil)
        }
        let disposeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.apivideo_live_stream.LiveStreamHostApi.dispose\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            disposeChannel.setMessageHandler { _, reply in
                do {
                    try api.dispose()
                    reply(wrapResult(nil))
                } catch {
                    reply(wrapError(error))
                }
            }
        } else {
            disposeChannel.setMessageHandler(nil)
        }
        let setVideoConfigChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.apivideo_live_stream.LiveStreamHostApi.setVideoConfig\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            setVideoConfigChannel.setMessageHandler { message, reply in
                let args = message as! [Any?]
                let videoConfigArg = args[0] as! NativeVideoConfig
                api.setVideoConfig(videoConfig: videoConfigArg) { result in
                    switch result {
                    case .success:
                        reply(wrapResult(nil))
                    case let .failure(error):
                        reply(wrapError(error))
                    }
                }
            }
        } else {
            setVideoConfigChannel.setMessageHandler(nil)
        }
        let setAudioConfigChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.apivideo_live_stream.LiveStreamHostApi.setAudioConfig\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            setAudioConfigChannel.setMessageHandler { message, reply in
                let args = message as! [Any?]
                let audioConfigArg = args[0] as! NativeAudioConfig
                api.setAudioConfig(audioConfig: audioConfigArg) { result in
                    switch result {
                    case .success:
                        reply(wrapResult(nil))
                    case let .failure(error):
                        reply(wrapError(error))
                    }
                }
            }
        } else {
            setAudioConfigChannel.setMessageHandler(nil)
        }
        let startStreamingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.apivideo_live_stream.LiveStreamHostApi.startStreaming\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            startStreamingChannel.setMessageHandler { message, reply in
                let args = message as! [Any?]
                let streamKeyArg = args[0] as! String
                let urlArg = args[1] as! String
                do {
                    try api.startStreaming(streamKey: streamKeyArg, url: urlArg)
                    reply(wrapResult(nil))
                } catch {
                    reply(wrapError(error))
                }
            }
        } else {
            startStreamingChannel.setMessageHandler(nil)
        }
        let stopStreamingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.apivideo_live_stream.LiveStreamHostApi.stopStreaming\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            stopStreamingChannel.setMessageHandler { _, reply in
                do {
                    try api.stopStreaming()
                    reply(wrapResult(nil))
                } catch {
                    reply(wrapError(error))
                }
            }
        } else {
            stopStreamingChannel.setMessageHandler(nil)
        }
        let startPreviewChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.apivideo_live_stream.LiveStreamHostApi.startPreview\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            startPreviewChannel.setMessageHandler { _, reply in
                api.startPreview { result in
                    switch result {
                    case .success:
                        reply(wrapResult(nil))
                    case let .failure(error):
                        reply(wrapError(error))
                    }
                }
            }
        } else {
            startPreviewChannel.setMessageHandler(nil)
        }
        let stopPreviewChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.apivideo_live_stream.LiveStreamHostApi.stopPreview\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            stopPreviewChannel.setMessageHandler { _, reply in
                do {
                    try api.stopPreview()
                    reply(wrapResult(nil))
                } catch {
                    reply(wrapError(error))
                }
            }
        } else {
            stopPreviewChannel.setMessageHandler(nil)
        }
        let getIsStreamingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.apivideo_live_stream.LiveStreamHostApi.getIsStreaming\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            getIsStreamingChannel.setMessageHandler { _, reply in
                do {
                    let result = try api.getIsStreaming()
                    reply(wrapResult(result))
                } catch {
                    reply(wrapError(error))
                }
            }
        } else {
            getIsStreamingChannel.setMessageHandler(nil)
        }
        let getCameraIdChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.apivideo_live_stream.LiveStreamHostApi.getCameraId\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            getCameraIdChannel.setMessageHandler { _, reply in
                do {
                    let result = try api.getCameraId()
                    reply(wrapResult(result))
                } catch {
                    reply(wrapError(error))
                }
            }
        } else {
            getCameraIdChannel.setMessageHandler(nil)
        }
        let setCameraIdChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.apivideo_live_stream.LiveStreamHostApi.setCameraId\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            setCameraIdChannel.setMessageHandler { message, reply in
                let args = message as! [Any?]
                let cameraIdArg = args[0] as! String
                api.setCameraId(cameraId: cameraIdArg) { result in
                    switch result {
                    case .success:
                        reply(wrapResult(nil))
                    case let .failure(error):
                        reply(wrapError(error))
                    }
                }
            }
        } else {
            setCameraIdChannel.setMessageHandler(nil)
        }
        let getIsMutedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.apivideo_live_stream.LiveStreamHostApi.getIsMuted\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            getIsMutedChannel.setMessageHandler { _, reply in
                do {
                    let result = try api.getIsMuted()
                    reply(wrapResult(result))
                } catch {
                    reply(wrapError(error))
                }
            }
        } else {
            getIsMutedChannel.setMessageHandler(nil)
        }
        let setIsMutedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.apivideo_live_stream.LiveStreamHostApi.setIsMuted\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            setIsMutedChannel.setMessageHandler { message, reply in
                let args = message as! [Any?]
                let isMutedArg = args[0] as! Bool
                do {
                    try api.setIsMuted(isMuted: isMutedArg)
                    reply(wrapResult(nil))
                } catch {
                    reply(wrapError(error))
                }
            }
        } else {
            setIsMutedChannel.setMessageHandler(nil)
        }
        let getVideoResolutionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.apivideo_live_stream.LiveStreamHostApi.getVideoResolution\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            getVideoResolutionChannel.setMessageHandler { _, reply in
                do {
                    let result = try api.getVideoResolution()
                    reply(wrapResult(result))
                } catch {
                    reply(wrapError(error))
                }
            }
        } else {
            getVideoResolutionChannel.setMessageHandler(nil)
        }
    }
}

/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol LiveStreamFlutterApiProtocol {
    func onIsConnectedChanged(isConnected isConnectedArg: Bool, completion: @escaping (Result<Void, PigeonError>) -> Void)
    func onConnectionFailed(message messageArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void)
    func onVideoSizeChanged(resolution resolutionArg: NativeResolution, completion: @escaping (Result<Void, PigeonError>) -> Void)
    func onError(code codeArg: String, message messageArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void)
}

class LiveStreamFlutterApi: LiveStreamFlutterApiProtocol {
    private let binaryMessenger: FlutterBinaryMessenger
    private let messageChannelSuffix: String
    init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
        self.binaryMessenger = binaryMessenger
        self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    }

    var codec: GeneratedLiveStreamApiPigeonCodec {
        return GeneratedLiveStreamApiPigeonCodec.shared
    }

    func onIsConnectedChanged(isConnected isConnectedArg: Bool, completion: @escaping (Result<Void, PigeonError>) -> Void) {
        let channelName = "dev.flutter.pigeon.apivideo_live_stream.LiveStreamFlutterApi.onIsConnectedChanged\(messageChannelSuffix)"
        let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
        channel.sendMessage([isConnectedArg] as [Any?]) { response in
            guard let listResponse = response as? [Any?] else {
                completion(.failure(createConnectionError(withChannelName: channelName)))
                return
            }
            if listResponse.count > 1 {
                let code: String = listResponse[0] as! String
                let message: String? = nilOrValue(listResponse[1])
                let details: String? = nilOrValue(listResponse[2])
                completion(.failure(PigeonError(code: code, message: message, details: details)))
            } else {
                completion(.success(()))
            }
        }
    }

    func onConnectionFailed(message messageArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void) {
        let channelName = "dev.flutter.pigeon.apivideo_live_stream.LiveStreamFlutterApi.onConnectionFailed\(messageChannelSuffix)"
        let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
        channel.sendMessage([messageArg] as [Any?]) { response in
            guard let listResponse = response as? [Any?] else {
                completion(.failure(createConnectionError(withChannelName: channelName)))
                return
            }
            if listResponse.count > 1 {
                let code: String = listResponse[0] as! String
                let message: String? = nilOrValue(listResponse[1])
                let details: String? = nilOrValue(listResponse[2])
                completion(.failure(PigeonError(code: code, message: message, details: details)))
            } else {
                completion(.success(()))
            }
        }
    }

    func onVideoSizeChanged(resolution resolutionArg: NativeResolution, completion: @escaping (Result<Void, PigeonError>) -> Void) {
        let channelName = "dev.flutter.pigeon.apivideo_live_stream.LiveStreamFlutterApi.onVideoSizeChanged\(messageChannelSuffix)"
        let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
        channel.sendMessage([resolutionArg] as [Any?]) { response in
            guard let listResponse = response as? [Any?] else {
                completion(.failure(createConnectionError(withChannelName: channelName)))
                return
            }
            if listResponse.count > 1 {
                let code: String = listResponse[0] as! String
                let message: String? = nilOrValue(listResponse[1])
                let details: String? = nilOrValue(listResponse[2])
                completion(.failure(PigeonError(code: code, message: message, details: details)))
            } else {
                completion(.success(()))
            }
        }
    }

    func onError(code codeArg: String, message messageArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void) {
        let channelName = "dev.flutter.pigeon.apivideo_live_stream.LiveStreamFlutterApi.onError\(messageChannelSuffix)"
        let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
        channel.sendMessage([codeArg, messageArg] as [Any?]) { response in
            guard let listResponse = response as? [Any?] else {
                completion(.failure(createConnectionError(withChannelName: channelName)))
                return
            }
            if listResponse.count > 1 {
                let code: String = listResponse[0] as! String
                let message: String? = nilOrValue(listResponse[1])
                let details: String? = nilOrValue(listResponse[2])
                completion(.failure(PigeonError(code: code, message: message, details: details)))
            } else {
                completion(.success(()))
            }
        }
    }
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol CameraInfoHostApi {
    func getSensorRotationDegrees(cameraId: String) throws -> Int64
    func getLensDirection(cameraId: String) throws -> NativeCameraLensDirection
    func getMinZoomRatio(cameraId: String) throws -> Double
    func getMaxZoomRatio(cameraId: String) throws -> Double
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
enum CameraInfoHostApiSetup {
    static var codec: FlutterStandardMessageCodec { GeneratedLiveStreamApiPigeonCodec.shared }
    /// Sets up an instance of `CameraInfoHostApi` to handle messages through the `binaryMessenger`.
    static func setUp(binaryMessenger: FlutterBinaryMessenger, api: CameraInfoHostApi?, messageChannelSuffix: String = "") {
        let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
        let getSensorRotationDegreesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.apivideo_live_stream.CameraInfoHostApi.getSensorRotationDegrees\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            getSensorRotationDegreesChannel.setMessageHandler { message, reply in
                let args = message as! [Any?]
                let cameraIdArg = args[0] as! String
                do {
                    let result = try api.getSensorRotationDegrees(cameraId: cameraIdArg)
                    reply(wrapResult(result))
                } catch {
                    reply(wrapError(error))
                }
            }
        } else {
            getSensorRotationDegreesChannel.setMessageHandler(nil)
        }
        let getLensDirectionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.apivideo_live_stream.CameraInfoHostApi.getLensDirection\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            getLensDirectionChannel.setMessageHandler { message, reply in
                let args = message as! [Any?]
                let cameraIdArg = args[0] as! String
                do {
                    let result = try api.getLensDirection(cameraId: cameraIdArg)
                    reply(wrapResult(result))
                } catch {
                    reply(wrapError(error))
                }
            }
        } else {
            getLensDirectionChannel.setMessageHandler(nil)
        }
        let getMinZoomRatioChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.apivideo_live_stream.CameraInfoHostApi.getMinZoomRatio\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            getMinZoomRatioChannel.setMessageHandler { message, reply in
                let args = message as! [Any?]
                let cameraIdArg = args[0] as! String
                do {
                    let result = try api.getMinZoomRatio(cameraId: cameraIdArg)
                    reply(wrapResult(result))
                } catch {
                    reply(wrapError(error))
                }
            }
        } else {
            getMinZoomRatioChannel.setMessageHandler(nil)
        }
        let getMaxZoomRatioChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.apivideo_live_stream.CameraInfoHostApi.getMaxZoomRatio\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            getMaxZoomRatioChannel.setMessageHandler { message, reply in
                let args = message as! [Any?]
                let cameraIdArg = args[0] as! String
                do {
                    let result = try api.getMaxZoomRatio(cameraId: cameraIdArg)
                    reply(wrapResult(result))
                } catch {
                    reply(wrapError(error))
                }
            }
        } else {
            getMaxZoomRatioChannel.setMessageHandler(nil)
        }
    }
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol CameraSettingsHostApi {
    func setZoomRatio(zoomRatio: Double) throws
    func getZoomRatio() throws -> Double
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
enum CameraSettingsHostApiSetup {
    static var codec: FlutterStandardMessageCodec { GeneratedLiveStreamApiPigeonCodec.shared }
    /// Sets up an instance of `CameraSettingsHostApi` to handle messages through the `binaryMessenger`.
    static func setUp(binaryMessenger: FlutterBinaryMessenger, api: CameraSettingsHostApi?, messageChannelSuffix: String = "") {
        let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
        let setZoomRatioChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.apivideo_live_stream.CameraSettingsHostApi.setZoomRatio\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            setZoomRatioChannel.setMessageHandler { message, reply in
                let args = message as! [Any?]
                let zoomRatioArg = args[0] as! Double
                do {
                    try api.setZoomRatio(zoomRatio: zoomRatioArg)
                    reply(wrapResult(nil))
                } catch {
                    reply(wrapError(error))
                }
            }
        } else {
            setZoomRatioChannel.setMessageHandler(nil)
        }
        let getZoomRatioChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.apivideo_live_stream.CameraSettingsHostApi.getZoomRatio\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            getZoomRatioChannel.setMessageHandler { _, reply in
                do {
                    let result = try api.getZoomRatio()
                    reply(wrapResult(result))
                } catch {
                    reply(wrapError(error))
                }
            }
        } else {
            getZoomRatioChannel.setMessageHandler(nil)
        }
    }
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol CameraProviderHostApi {
    func getAvailableCameraIds() throws -> [String]
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
enum CameraProviderHostApiSetup {
    static var codec: FlutterStandardMessageCodec { GeneratedLiveStreamApiPigeonCodec.shared }
    /// Sets up an instance of `CameraProviderHostApi` to handle messages through the `binaryMessenger`.
    static func setUp(binaryMessenger: FlutterBinaryMessenger, api: CameraProviderHostApi?, messageChannelSuffix: String = "") {
        let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
        let getAvailableCameraIdsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.apivideo_live_stream.CameraProviderHostApi.getAvailableCameraIds\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            getAvailableCameraIdsChannel.setMessageHandler { _, reply in
                do {
                    let result = try api.getAvailableCameraIds()
                    reply(wrapResult(result))
                } catch {
                    reply(wrapError(error))
                }
            }
        } else {
            getAvailableCameraIdsChannel.setMessageHandler(nil)
        }
    }
}
